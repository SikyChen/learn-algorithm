/**
 * 荷兰国旗问题(三色)
 * 给定一个数组，和一个数组中存在的数 p
 * 根据数 p 将数组划分，小于 p 的在左边，等于 p 的在中间，大于 p 的在右边
 * 结果返回一个两个值的数组，分别是中间段的左右两下标
 * 
 * 例：
 * [2, 4, 4, 7, 1, 6, 4, 2]
 * 它的一种结果数组可能为
 * [2, 1, 2, 4, 4, 4, 7, 6]
 *           ^     ^
 * 返回结果是两个下标
 * [3, 5]
 * 
 * @returns {Array} 两个下标值组成的集合
 */

/**
 * 解法 p = 4
 * 设置左下标 L ，下标小于 L 的数，都小于 4
 * 设置右下标 R ，下标大于 R 的数，都大于 4
 * 设置循环的下标为 i
 * 开始循环
 * [2, 4, 4, 7, 1, 6, 4, 2]
 *  L                    R
 *  i
 * 
 * 当 nums[i] < 4 ，swap(i, L)；
 * 两种情况
 *   当 i == L 时：说明 L 小于 4，还需要向右移动找 4，使 L 成为第一个 4，所以 L++ i++
 *   当 i > L 时：交换后 L 上的数小于 4 了，所以 L++，交换后 i 上的数等于 4 了，所以 i++
 * 
 * --------------
 * [2, 4, 4, 7, 1, 6, 4, 2]
 *     L                 R
 *     i
 * 
 * 当 nums[i] == 4
 * 两种情况
 *   当 i == L 时，说明 L 第一次找到 4 ，即当前 4 是最左侧的 4，L 停留在此位置不变 i++ 即可
 *   当 i > L 时，说明 L 上已经是 4，并且 L 到 i 之间的所有数，都是 4 了，L 是最左侧的 4，所以L不变，i++ 即可
 * 
 * --------------
 * [2, 4, 4, 7, 1, 6, 4, 2]
 *     L                 R
 *        i
 * 
 * 同上
 * 
 * --------------
 * [2, 4, 4, 7, 1, 6, 4, 2]
 *     L                 R
 *           i
 * 
 * 当 nums[i] > 4，swap(i, R)
 * 交换之后 i 位置上的数是未知的，需要再进行对比，所以次数 i 保持不变，不需要 i++
 * 交换之后 R 位置上的数是已知的，肯定是大于 4 的，可以保留在右边，所以 R 的位置 R--
 * 
 * --------------
 * [2, 4, 4, 2, 1, 6, 4, 7]
 *     L              R
 *           i
 * 
 * 当 nums[i] < 4 ，swap(i, L)；
 * 同上 i++ L++
 * 
 * --------------
 * [2, 2, 4, 4, 1, 6, 4, 7]
 *        L           R
 *              i
 * 
 * 当 nums[i] < 4 ，swap(i, L)；
 * 同上 i++ L++
 * 
 * --------------
 * [2, 2, 1, 4, 4, 6, 4, 7]
 *           L        R
 *                 i
 * 
 * 当 nums[i] > 4 ，swap(i, L)；
 * 同上 R--
 * 
 * --------------
 * [2, 2, 1, 4, 4, 4, 6, 7]
 *           L     R
 *                 i
 * 
 * 当 nums[i] == 4 ，swap(i, L)；
 * 同上 i++
 * 
 * --------------
 * [2, 2, 1, 4, 4, 4, 6, 7]
 *           L     R
 *                    i
 * 
 * i 已经大于 R 了，已经知道 R 右边的数，都是大于 4 的，所以不需要再进行比较，停止即可
 * 此时的 L 和 R，就是 p=4 时，中间部分的左右两下标了
 */

function partition (nums, p) {
  let l = 0;
  let r = nums.length - 1;
  let i = 0;

  while (i <= r) {
    if (nums[i] < p) {
      swap(nums, i, l);
      l++;
      i++;
    }
    else if (nums[i] > p) {
      swap(nums, i, r);
      r--;
    }
    else {
      i++;
    }
  }

  return [l, r];
}

// 交换位置
function swap(array, i, j) {
  [array[i], array[j]] = [array[j], array[i]];
}

// 测试代码
const arr = [2, 4, 4, 7, 1, 6, 4, 2];
// const arr = [2, 3, 1, 0, 4, 4, 4, 7];
console.log(partition(arr.concat(), 4));


/**
 * 暴力解法（此暴力解法已经跟荷兰国旗的字面意思无关了）
 * 准备变量数字 left ，算出小于 p 的数的数量，存入 left
 * 准备变量数字 mid ， 算出等于 p 的数的数量，存入 mid
 * 则结果为 [left, left + mid - 1]
 */
function partition2(nums, p) {
  let left = 0;
  let mid = 0;

  for(let i=0; i<nums.length; i++) {
    if (nums[i] < p) {
      left++;
    }
    if (nums[i] === p) {
      mid++;
    }
  }

  return [left, left + mid - 1];
}
// 测试代码
console.log('partition2', partition2(arr.concat(), 4));
